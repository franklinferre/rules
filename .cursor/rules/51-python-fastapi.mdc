
---
description: Python and FastAPI standards following Clean Architecture and DDD principles
globs:
  - "**/*.py"
  - "**/requirements*.txt"
  - "**/pyproject.toml"
  - "**/Pipfile"
alwaysApply: false
---

# Python & FastAPI Standards

## Project Structure (Clean Architecture)

```
src/
├── domain/              # Entities, Value Objects, Domain Events
│   ├── entities/
│   ├── value_objects/
│   ├── events/
│   └── exceptions/
├── application/         # Use Cases, DTOs, Interfaces
│   ├── use_cases/
│   ├── dtos/
│   └── interfaces/
├── infrastructure/      # Repositories, External Services
│   ├── repositories/
│   ├── external/
│   └── database/
└── presentation/        # Controllers, Serializers
    ├── api/
    ├── schemas/
    └── dependencies/

tests/
├── unit/               # Mirror src structure
├── integration/        # Integration tests
└── e2e/               # End-to-end tests
```

## FastAPI Patterns

### Dependency Injection
```python
from fastapi import Depends
from sqlalchemy.orm import Session

def get_db() -> Session:
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.post("/users/")
async def create_user(
    user_data: UserCreateSchema,
    db: Session = Depends(get_db),
    user_service: UserService = Depends(get_user_service)
):
    return await user_service.create(user_data, db)
```

### Validation with Pydantic
```python
from pydantic import BaseModel, EmailStr, validator
from typing import Optional

class UserCreateSchema(BaseModel):
    email: EmailStr
    name: str
    age: Optional[int] = None
    
    @validator('age')
    def validate_age(cls, v):
        if v is not None and (v < 0 or v > 150):
            raise ValueError('Age must be between 0 and 150')
        return v

class UserResponseSchema(BaseModel):
    id: int
    email: str
    name: str
    created_at: datetime
    
    class Config:
        from_attributes = True
```

### Async Patterns
- **Database**: Always async with SQLAlchemy/asyncpg
- **HTTP Calls**: httpx async client
- **Background Tasks**: BackgroundTasks for non-critical operations
- **Concurrency**: asyncio.gather for parallelization

### Error Handling
```python
from fastapi import HTTPException
from typing import Union

class UserNotFoundError(Exception):
    pass

class UserService:
    async def get_user(self, user_id: int) -> Union[User, None]:
        user = await self.repository.get_by_id(user_id)
        if not user:
            raise UserNotFoundError(f"User {user_id} not found")
        return user

@app.exception_handler(UserNotFoundError)
async def user_not_found_handler(request: Request, exc: UserNotFoundError):
    raise HTTPException(
        status_code=404,
        detail={"error": "USER_NOT_FOUND", "message": str(exc)}
    )
```

## Code Quality Standards

### Type Hints (100% Coverage)
```python
from typing import List, Optional, Dict, Any, Union
from pydantic import BaseModel

def process_users(
    users: List[User], 
    filters: Optional[Dict[str, Any]] = None
) -> List[UserResponseSchema]:
    """Process users with optional filters."""
    # Implementation
    pass
```

### Docstrings (Google Style)
```python
def calculate_user_score(user: User, metrics: List[Metric]) -> float:
    """Calculate user score based on metrics.
    
    Args:
        user: The user to calculate score for
        metrics: List of metrics to consider
        
    Returns:
        Calculated score as float between 0.0 and 1.0
        
    Raises:
        ValueError: If metrics list is empty
        UserNotFoundError: If user is invalid
        
    Example:
        >>> user = User(id=1, name="John")
        >>> metrics = [Metric(name="activity", value=0.8)]
        >>> score = calculate_user_score(user, metrics)
        >>> assert 0.0 <= score <= 1.0
    """
    if not metrics:
        raise ValueError("Metrics list cannot be empty")
    
    # Implementation
    return score
```

### Linting & Formatting
- **Tool**: Ruff (replaces flake8, isort, black)
- **Config**: pyproject.toml
- **Line Length**: 88 characters
- **Pre-commit**: Hooks configured

```toml
[tool.ruff]
line-length = 88
target-version = "py311"

[tool.ruff.lint]
select = ["E", "F", "W", "C90", "I", "N", "UP", "S", "B", "A", "C4", "T20"]
ignore = ["E501"]  # Line too long (handled by formatter)

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
```

## Domain-Driven Design

### Entities
```python
from dataclasses import dataclass
from typing import List
from datetime import datetime

@dataclass
class User:
    id: int
    email: str
    name: str
    created_at: datetime
    _domain_events: List[DomainEvent] = field(default_factory=list)
    
    def change_email(self, new_email: str) -> None:
        """Change user email and raise domain event."""
        old_email = self.email
        self.email = new_email
        self._domain_events.append(
            UserEmailChangedEvent(
                user_id=self.id,
                old_email=old_email,
                new_email=new_email
            )
        )
    
    def clear_events(self) -> List[DomainEvent]:
        events = self._domain_events.copy()
        self._domain_events.clear()
        return events
```

### Value Objects
```python
from dataclasses import dataclass
import re

@dataclass(frozen=True)
class Email:
    value: str
    
    def __post_init__(self):
        if not self._is_valid(self.value):
            raise ValueError(f"Invalid email: {self.value}")
    
    @staticmethod
    def _is_valid(email: str) -> bool:
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return bool(re.match(pattern, email))
```

### Repositories
```python
from abc import ABC, abstractmethod
from typing import List, Optional

class IUserRepository(ABC):
    @abstractmethod
    async def get_by_id(self, user_id: int) -> Optional[User]:
        pass
    
    @abstractmethod
    async def get_by_email(self, email: str) -> Optional[User]:
        pass
    
    @abstractmethod
    async def save(self, user: User) -> User:
        pass
    
    @abstractmethod
    async def delete(self, user_id: int) -> None:
        pass

class SQLAlchemyUserRepository(IUserRepository):
    def __init__(self, session: AsyncSession):
        self.session = session
    
    async def get_by_id(self, user_id: int) -> Optional[User]:
        result = await self.session.execute(
            select(UserModel).where(UserModel.id == user_id)
        )
        user_model = result.scalar_one_or_none()
        return self._to_domain(user_model) if user_model else None
```

## Testing Standards

### Unit Tests with pytest
```python
import pytest
from unittest.mock import Mock, AsyncMock

class TestUserService:
    @pytest.fixture
    def user_repository(self):
        return Mock(spec=IUserRepository)
    
    @pytest.fixture
    def user_service(self, user_repository):
        return UserService(user_repository)
    
    @pytest.mark.asyncio
    async def test_should_create_user_when_valid_data_provided(
        self, user_service, user_repository
    ):
        # Arrange
        user_data = UserCreateSchema(email="test@example.com", name="Test")
        expected_user = User(id=1, email="test@example.com", name="Test")
        user_repository.save = AsyncMock(return_value=expected_user)
        
        # Act
        result = await user_service.create(user_data)
        
        # Assert
        assert result.email == user_data.email
        assert result.name == user_data.name
        user_repository.save.assert_called_once()
```

### Integration Tests
```python
import pytest
from httpx import AsyncClient
from testcontainers.postgres import PostgresContainer

@pytest.fixture(scope="session")
def postgres_container():
    with PostgresContainer("postgres:15") as postgres:
        yield postgres

@pytest.fixture
async def client(postgres_container):
    # Setup test database
    database_url = postgres_container.get_connection_url()
    app.dependency_overrides[get_db] = lambda: get_test_db(database_url)
    
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac

@pytest.mark.asyncio
async def test_create_user_endpoint(client: AsyncClient):
    # Arrange
    user_data = {"email": "test@example.com", "name": "Test User"}
    
    # Act
    response = await client.post("/users/", json=user_data)
    
    # Assert
    assert response.status_code == 201
    data = response.json()
    assert data["email"] == user_data["email"]
    assert data["name"] == user_data["name"]
```

## Security Best Practices

### Input Validation
- Always use Pydantic models for request validation
- Implement custom validators for business rules
- Sanitize inputs before processing

### Authentication & Authorization
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer
import jwt

security = HTTPBearer()

async def get_current_user(token: str = Depends(security)) -> User:
    try:
        payload = jwt.decode(token.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: int = payload.get("sub")
        if user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication credentials"
            )
    except jwt.PyJWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials"
        )
    
    user = await user_service.get_by_id(user_id)
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found"
        )
    return user
```

### Environment Configuration
```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    database_url: str
    secret_key: str
    algorithm: str = "HS256"
    access_token_expire_minutes: int = 30
    
    class Config:
        env_file = ".env"

settings = Settings()
```

## Anti-Patterns (Forbidden)

### Python
- ❌ Bare except clauses
- ❌ Mutable default arguments
- ❌ Global variables
- ❌ `import *`
- ❌ String formatting with % or .format() (use f-strings)

### FastAPI
- ❌ Synchronous database operations
- ❌ Missing dependency injection
- ❌ Hardcoded configuration
- ❌ Missing error handling
- ❌ No request/response validation

### Architecture
- ❌ Domain depending on infrastructure
- ❌ Anemic domain model
- ❌ God objects/classes
- ❌ Circular dependencies

@ref:testing#unit-tests
@ref:security#input-validation
@ref:gates-system#g3-coding
