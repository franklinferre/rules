
---
description: "Modern JavaScript development rules with ES2023+ features"
globs: ["**/*.js", "**/*.mjs", "**/*.cjs"]
alwaysApply: false
---

# JavaScript Development Rules

## Core Principles
- **Modern ES2023+**: Use latest JavaScript features
- **Functional Programming**: Prefer immutable patterns and pure functions
- **Module System**: Use ES modules consistently
- **Error Handling**: Implement proper async error handling
- **Performance**: Write efficient, optimized code

## Modern JavaScript Features

### Variable Declarations
```javascript
// ✅ Good - Use const by default, let when reassignment needed
const users = await fetchUsers();
let currentIndex = 0;

// ❌ Avoid - var has function scope issues
var globalVar = 'avoid this';

// ✅ Good - Destructuring with defaults
const { name = 'Anonymous', email } = user;
const [first, second, ...rest] = items;
```

### Arrow Functions and Methods
```javascript
// ✅ Good - Concise arrow functions
const processUsers = users => users
  .filter(user => user.active)
  .map(user => ({ ...user, processed: true }));

// ✅ Good - Async arrow functions
const fetchUserData = async (userId) => {
  try {
    const response = await fetch(`/api/users/${userId}`);
    return await response.json();
  } catch (error) {
    console.error('Failed to fetch user:', error);
    throw error;
  }
};

// ✅ Good - Method shorthand in objects
const userService = {
  async create(userData) {
    return await this.repository.save(userData);
  },
  
  find(id) {
    return this.repository.findById(id);
  }
};
```

## Async Programming

### Promise Patterns
```javascript
// ✅ Good - Promise.all for concurrent operations
const fetchUserProfile = async (userId) => {
  const [user, preferences, activity] = await Promise.all([
    fetchUser(userId),
    fetchUserPreferences(userId),
    fetchUserActivity(userId)
  ]);
  
  return { user, preferences, activity };
};

// ✅ Good - Promise.allSettled for error resilience
const fetchMultipleUsers = async (userIds) => {
  const results = await Promise.allSettled(
    userIds.map(id => fetchUser(id))
  );
  
  return results
    .filter(result => result.status === 'fulfilled')
    .map(result => result.value);
};

// ✅ Good - Proper error boundaries
const safeAsyncOperation = async (operation) => {
  try {
    const result = await operation();
    return { success: true, data: result };
  } catch (error) {
    console.error('Operation failed:', error);
    return { success: false, error: error.message };
  }
};
```

### Async Iteration
```javascript
// ✅ Good - Async generators
async function* fetchUsersInBatches(batchSize = 100) {
  let offset = 0;
  let hasMore = true;
  
  while (hasMore) {
    const batch = await fetchUsers({ limit: batchSize, offset });
    if (batch.length === 0) {
      hasMore = false;
    } else {
      yield batch;
      offset += batchSize;
    }
  }
}

// ✅ Good - for await...of
const processAllUsers = async () => {
  for await (const userBatch of fetchUsersInBatches()) {
    await Promise.all(userBatch.map(processUser));
  }
};
```

## Functional Programming

### Immutability Patterns
```javascript
// ✅ Good - Immutable updates
const updateUser = (user, updates) => ({
  ...user,
  ...updates,
  updatedAt: new Date().toISOString()
});

const addItemToList = (list, item) => [...list, item];

const removeItemFromList = (list, itemId) => 
  list.filter(item => item.id !== itemId);

// ✅ Good - Deep cloning for complex objects
const deepClone = (obj) => structuredClone(obj);

// ✅ Good - Immutable array operations
const processItems = (items) => items
  .filter(item => item.active)
  .map(item => ({ ...item, processed: true }))
  .sort((a, b) => a.priority - b.priority);
```

### Higher-Order Functions
```javascript
// ✅ Good - Reusable higher-order functions
const withRetry = (fn, maxAttempts = 3) => async (...args) => {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn(...args);
    } catch (error) {
      if (attempt === maxAttempts) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
    }
  }
};

const withLogging = (fn) => (...args) => {
  console.log(`Calling ${fn.name} with:`, args);
  const result = fn(...args);
  console.log(`${fn.name} returned:`, result);
  return result;
};

// Usage
const resilientFetch = withRetry(fetch);
const loggedProcess = withLogging(processData);
```

## Module System

### ES Module Best Practices
```javascript
// ✅ Good - Named exports
export const createUser = (userData) => ({ ...userData, id: generateId() });
export const validateUser = (user) => user.email && user.name;

// ✅ Good - Default export for main functionality
export default class UserService {
  constructor(repository) {
    this.repository = repository;
  }
  
  async create(userData) {
    const validatedData = validateUser(userData);
    return await this.repository.save(validatedData);
  }
}

// ✅ Good - Re-exports for barrel files
export { UserService } from './UserService.js';
export { UserRepository } from './UserRepository.js';
export * from './types.js';
```

### Dynamic Imports
```javascript
// ✅ Good - Lazy loading modules
const loadUserModule = async () => {
  const { UserService } = await import('./services/UserService.js');
  return new UserService();
};

// ✅ Good - Conditional imports
const getAnalytics = async () => {
  if (process.env.NODE_ENV === 'production') {
    const { Analytics } = await import('./analytics/production.js');
    return new Analytics();
  } else {
    const { MockAnalytics } = await import('./analytics/mock.js');
    return new MockAnalytics();
  }
};
```

## Error Handling

### Custom Error Classes
```javascript
class UserServiceError extends Error {
  constructor(message, code, details = {}) {
    super(message);
    this.name = 'UserServiceError';
    this.code = code;
    this.details = details;
  }
}

class ValidationError extends UserServiceError {
  constructor(field, value, message) {
    super(`Validation failed for ${field}: ${message}`, 'VALIDATION_ERROR', {
      field,
      value,
      message
    });
    this.name = 'ValidationError';
  }
}

// ✅ Good - Error handling with context
const handleApiError = (error, context = {}) => {
  const errorInfo = {
    message: error.message,
    stack: error.stack,
    context,
    timestamp: new Date().toISOString()
  };
  
  console.error('API Error:', errorInfo);
  
  // Send to error tracking service
  if (typeof window !== 'undefined' && window.errorTracker) {
    window.errorTracker.captureException(error, errorInfo);
  }
};
```

## Performance Optimization

### Memoization and Caching
```javascript
// ✅ Good - Simple memoization
const memoize = (fn) => {
  const cache = new Map();
  return (...args) => {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
};

// ✅ Good - WeakMap for object caching
const processedObjects = new WeakMap();

const processObject = (obj) => {
  if (processedObjects.has(obj)) {
    return processedObjects.get(obj);
  }
  
  const processed = expensiveProcessing(obj);
  processedObjects.set(obj, processed);
  return processed;
};
```

### Debouncing and Throttling
```javascript
// ✅ Good - Debounce implementation
const debounce = (fn, delay) => {
  let timeoutId;
  return (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
};

// ✅ Good - Throttle implementation
const throttle = (fn, limit) => {
  let inThrottle;
  return (...args) => {
    if (!inThrottle) {
      fn(...args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
};

// Usage
const debouncedSearch = debounce(searchUsers, 300);
const throttledScroll = throttle(handleScroll, 100);
```

## DOM Manipulation (Browser)

### Modern DOM APIs
```javascript
// ✅ Good - Query selectors and modern methods
const findElements = (selector) => [...document.querySelectorAll(selector)];

const createElement = (tag, attributes = {}, children = []) => {
  const element = document.createElement(tag);
  
  Object.entries(attributes).forEach(([key, value]) => {
    if (key.startsWith('on')) {
      element.addEventListener(key.slice(2).toLowerCase(), value);
    } else {
      element.setAttribute(key, value);
    }
  });
  
  children.forEach(child => {
    if (typeof child === 'string') {
      element.appendChild(document.createTextNode(child));
    } else {
      element.appendChild(child);
    }
  });
  
  return element;
};

// ✅ Good - Event delegation
const setupEventDelegation = (container, selector, eventType, handler) => {
  container.addEventListener(eventType, (event) => {
    if (event.target.matches(selector)) {
      handler(event);
    }
  });
};
```

## Node.js Specific

### File System Operations
```javascript
import { promises as fs } from 'fs';
import path from 'path';

// ✅ Good - Async file operations
const readJsonFile = async (filePath) => {
  try {
    const data = await fs.readFile(filePath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    if (error.code === 'ENOENT') {
      return null; // File doesn't exist
    }
    throw error;
  }
};

const writeJsonFile = async (filePath, data) => {
  const dir = path.dirname(filePath);
  await fs.mkdir(dir, { recursive: true });
  await fs.writeFile(filePath, JSON.stringify(data, null, 2));
};
```

### Environment Configuration
```javascript
// ✅ Good - Environment validation
const getConfig = () => {
  const requiredEnvVars = ['DATABASE_URL', 'JWT_SECRET', 'PORT'];
  const missing = requiredEnvVars.filter(key => !process.env[key]);
  
  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }
  
  return {
    databaseUrl: process.env.DATABASE_URL,
    jwtSecret: process.env.JWT_SECRET,
    port: parseInt(process.env.PORT, 10),
    nodeEnv: process.env.NODE_ENV || 'development'
  };
};
```

## Testing Patterns

### Unit Testing
```javascript
// ✅ Good - Test structure
describe('UserService', () => {
  let userService;
  let mockRepository;
  
  beforeEach(() => {
    mockRepository = {
      save: jest.fn(),
      findById: jest.fn(),
      delete: jest.fn()
    };
    userService = new UserService(mockRepository);
  });
  
  describe('create', () => {
    it('should create user with valid data', async () => {
      const userData = { name: 'John', email: 'john@example.com' };
      const expectedUser = { ...userData, id: '123' };
      
      mockRepository.save.mockResolvedValue(expectedUser);
      
      const result = await userService.create(userData);
      
      expect(result).toEqual(expectedUser);
      expect(mockRepository.save).toHaveBeenCalledWith(userData);
    });
    
    it('should throw error for invalid data', async () => {
      const invalidData = { name: '' };
      
      await expect(userService.create(invalidData))
        .rejects
        .toThrow(ValidationError);
    });
  });
});
```

## Security Best Practices

### Input Sanitization
```javascript
// ✅ Good - Input validation
const sanitizeInput = (input) => {
  if (typeof input !== 'string') return '';
  return input
    .trim()
    .replace(/[<>]/g, '') // Basic XSS prevention
    .slice(0, 1000); // Prevent extremely long inputs
};

const validateEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

const validatePassword = (password) => {
  return password.length >= 8 && 
         /[A-Z]/.test(password) && 
         /[a-z]/.test(password) && 
         /\d/.test(password);
};
```

## Project Structure
```
src/
├── components/      # Reusable components
├── services/        # Business logic
├── utils/          # Utility functions
├── constants/      # Application constants
├── types/          # Type definitions (if using JSDoc)
├── tests/          # Test files
└── config/         # Configuration files
```

## Documentation
- Use JSDoc comments for all public functions
- Include usage examples in function documentation
- Maintain comprehensive README with setup instructions
- Document complex algorithms and business logic
- Use meaningful variable and function names
